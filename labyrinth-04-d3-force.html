<html>

<head>
  <script src="https://d3js.org/d3-collection.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-quadtree.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-force.v1.min.js"></script>
  <style>
    body {
      padding: 10;
      margin: 0
    }
  </style>
</head>

<body>

  <canvas width="600" height="600"></canvas>

  <script>
    const TAU = Math.PI * 2;
    const RADIUS = 20;
    let count = 50;

    const canvas = document.querySelector("canvas"),
      context = canvas.getContext("2d"),
      // width = canvas.width = window.innerWidth,
      // height = canvas.height = window.innerHeight;
      width = canvas.width,
      height = canvas.height;

    // MAKE CHAIN
    const nodes = [];
    const links = [];
    for (let i = 0; i < count; i++) {
      nodes.push({
        x: Math.cos(TAU * i / count) * 100 + width / 2,
        y: Math.sin(TAU * i / count) * 100 + height / 2,
      });
      if (i > 0) {
        links.push({
          source: nodes[i - 1],
          target: nodes[i],
        })
      }
      if (i === count - 1) {
        links.push({
          source: nodes[i],
          target: nodes[0],
        })
      }
    }
    const graph = { nodes, links, addOne }

    function addOne() {
      // const index = count - 1;
      // const index = 0;
      const index = Math.floor(count * Math.random());
      console.log(index);
      const prev = nodes[index];
      const next = nodes[(index + 1) % count];
      const newNode = {
        x: (prev.x + next.x) / 2,
        y: (prev.y + next.y) / 2,
      }
      nodes.splice((index + 1) % count, 0, newNode)
      links.splice(index, 1, {
        source: prev,
        target: newNode
      })
      links.splice((index + 1) % count, 0, {
        source: newNode,
        target: next
      })
      count++;
      simulation.nodes(nodes);
      simulation.alphaTarget(0.05);
      console.log(prev.index, newNode.index, next.index);
    }

    const simulation = d3.forceSimulation(nodes)
      .force("charge", d3.forceManyBody().strength(-5))
      .force("collide", d3.forceCollide().radius(RADIUS * 0.8).strength(0.9))
      .force("link", d3.forceLink(links).distance(RADIUS * 0.75).strength(1))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("size", forceBbox)
      .on("tick", ticked);

    function forceBbox(alpha) {
      for (let i = 0, n = nodes.length, k = alpha * 0.1; i < n; ++i) {
        let node = nodes[i];
        if (node.x < 5) {
          node.x = 5;
        }
        if (node.x > width - 5) {
          node.x = width - 5;
        }
        if (node.y < 5) {
          node.y = 5;
        }
        if (node.y > height - 5) {
          node.y = height - 5;
        }
      }
    }

    let lastAdd = 0;

    function ticked() {
      context.clearRect(0, 0, width, height);

      context.strokeStyle = "#999";
      graph.nodes.forEach(drawNode);

      context.beginPath();
      graph.links.forEach(drawLink);
      context.strokeStyle = "#000";
      context.stroke();

      if (count < 500 && Date.now() > lastAdd + 50) {
        lastAdd = Date.now()
        addOne()
      }
    }
    addOne();
    addOne();

    function drawLink(d) {
      context.moveTo(d.source.x, d.source.y);
      context.lineTo(d.target.x, d.target.y);
    }

    function drawNode(d) {
      context.beginPath();
      context.arc(d.x, d.y, 3, 0, TAU);
      context.stroke();
      context.beginPath();
      context.arc(d.x, d.y, RADIUS, 0, TAU);
      context.stroke();
    }

  </script>
</body>

</html>